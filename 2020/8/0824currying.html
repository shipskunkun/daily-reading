<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
</body>
<script>

/*
function currying(fn,...args){
    if(fn.length <= args.length){
        return fn(...args)
    }
    return function(...args1){
        console.log(args, args1)
        return currying(fn,...args,...args1)
    }
}
function add(a,b,c){
    return a + b + c
}
add(1,2,3) // 6
var curryingAdd = currying(add);

let f1 = curryingAdd(1)  // []  [1]
let f2 = f1(2) // [1] [2]
let f3 = f2(3)// [1,2]  [3]

*/



// 如果用reduce 怎么做？



var obj = {
    a: {
        b: {
            c: 1
        }
    }
}
let a = find(obj, 'a.b.c') //1
let b = find(obj, 'a.d.c') //undefined

function find(obj, str) {
    let arr = str.split(".");
    let result  = obj;
    arr.reduce((acc, cur, index, arr)=>{
        return 
    }, obj)
    return result
}


function deepCopy(originObj, map = new WeakMap()) {
	    // 判断是否为基本数据类型
	    if(isObject(originObj)) {
	        // 判断是否为循环引用
	        if(map.get(originObj)) {
	            return map.get(originObj);
	        }
	       
	        // 判断是否为几种特殊需要处理的类型
	        let type = [Date, RegExp, Set, Map, WeakMap, WeakSet];
	        if(type.includes(originObj.constructor)) {
	            return new originObj.constructor(originObj);
	        }
	        // 其他类型
	        let allDesc = Object.getOwnPropertyDescriptors(originObj);
	        let cloneObj = Object.create(Object.getPrototypeOf(originObj), allDesc);
	
	        // Reflect.ownKeys 可以获取到
	        for(const prop of Reflect.ownKeys(originObj)) {
	            cloneObj[prop] = isObject(originObj[prop]) && typeof originObj[prop] !== 'function' ? deepCopy(originObj[prop], map) : originObj[prop];
	        }
	        return cloneObj;
	    } else {
	        return originObj;
	    }
	}



</script>

</html>